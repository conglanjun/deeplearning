## 第二章 线性代数

### 2.1 标量 向量 矩阵 张量

- 标量（Scalar）：一个标量就是一个单独的数。我们用斜体表示标量。标量通常被赋予小写的变量名称。例如：实数标量，令 s ∈ R；自然数标量，令n ∈ N。

- 向量 (Vector)：一个向量是一列数。这些数是有序排列的。通过索引下标确定单独的元素。向量 x 的第一个元素是 x <sup>1</sup> ，将向量写成列向量的形式：
  $$
  x = \left[\matrix{
  x_1\\
  x_2\\
  ...\\
  x_n}
  \right]
  $$

- 矩阵（matrix）：矩阵是一个二维数组，其中每个元素被两个数字确定。例如实数矩阵高度为m，宽度为n，表示为A ∈ R<sup>m×n</sup>，元素表示为A<sub>1,1</sub>，A<sub>m,n</sub>。我们用 : 表示矩阵的一行或者一列:A<sub>i,:</sub> 为第 i 行，A<sub>:,j</sub> 为第 j 列。矩阵写成：

$$
\left[\matrix{
A_{1,1} && A_{1,2}\\
A_{2,1} && A_{2,2}
}
\right]
$$

​       f(A)<sub>i,j</sub> 表示函数f 作用在 A 上输出的矩阵的第 i 行第 j 列元素。

- 张量（Tensor）：超过二维的数组，用A表示张量，A<sub>i,j,k</sub>表示三维张量的元素。

```python
import numpy as np

# 标量
s = 3
# 向量
v = np.array([1,2])
# 矩阵
m = np.array([[1,2],[3,4]])
# 张量
t = np.array([
    [[1,2,3],[4,5,6],[7,8,9]],
    [[11,12,13],[14,15,16],[17,18,19]],
    [[21,22,23],[24,25,26],[27,28,29]]
])
print("标量：" + str(s))
print("向量：" + str(v))
print("矩阵：" + str(m))
print("张量：" + str(t))

标量：3
向量：[1 2]
矩阵：[[1 2]
 [3 4]]
张量：[[[ 1  2  3]
  [ 4  5  6]
  [ 7  8  9]]

 [[11 12 13]
  [14 15 16]
  [17 18 19]]

 [[21 22 23]
  [24 25 26]
  [27 28 29]]]
```

矩阵的转置A<sup>T</sup><sub>i,j</sub> = A<sub>j,i</sub>，对角线元素对换。

矩阵加法对应元素相加，要求两个矩阵形状一样。
$$
C = A + B, C_{i,j} = A_{i,j} + B_{i,j}
$$
 我们允许矩阵和向量相加得到一个矩阵，把 b 加到了 A 的每一行上，本质上是构造了一个将 b 按行复制的一个新矩阵，这种机制叫做广

播 (Broadcasting):
$$
C = A + b, C_{i,j} = A_{i,j} + b_j
$$

```python
# 矩阵相加
a = np.array([[1.0,2.0],[3.0,4.0]])
b = np.array([[6.0,7.0],[8.0,9.0]])
print('矩阵相加：', a + b)

# 矩阵与向量相加，广播
c = np.array([[4.0],[5.0]])
print('广播：', a + c)
矩阵相加： [[ 7.  9.]
 [11. 13.]]
广播： [[5. 6.]
 [8. 9.]]
```

### 2.2 矩阵乘法

两个矩阵相乘得到第三个矩阵，A 的形状为 m × n，B 的形状为 n × p，得到的矩阵为 C 的形状为 m × p:
$$
C = AB\\
C_i,_j = \sum_{k}{A_{i,k}B_{k,j}}
$$
矩阵相乘不是对应元素相乘，对应元素相乘是element-wise product 或 Hadamard product。
$$
A\bigodot B
$$
两个相同维数的向量 x 和 y 的点乘(Dot Product)或者内积，可以表示为 x<sup>⊤</sup>y。C=AB中计算C<sub>i,j</sub>作为A的i行和B的j列做dot product。

```python
# 矩阵乘法
m1 = np.array([[1.0,3.0],[1.0,0.0]])
m2 = np.array([[1.0,2.0],[5.0,0.0]])
print('矩阵乘法：', np.dot(m1,m2))
print('逐元素相乘：', np.multiply(m1, m2))
print('逐元素相乘：', m1*m2)

v1 = np.array([1.0,2.0])
v2 = np.array([4.0,5.0])
print('向量内积：', np.dot(v1,v2))

矩阵乘法： [[16.  2.]
 [ 1.  2.]]
逐元素相乘： [[1. 6.]
 [5. 0.]]
逐元素相乘： [[1. 6.]
 [5. 0.]]
向量内积： 14.0
```

### 2.3 单位矩阵和逆矩阵

单位矩阵 (Identity Matrix):单位矩阵乘以任意一个向量等于这个向量本身。
$$
I_n ∈ R^{n × n}, \forall x ∈ R^n,I_nx = x
$$
单位矩阵，所有的对角元素都为 1 ，其他元素都为 0，如:
$$
I_3=\left[\matrix{
1&0&0\\
0&1&0\\
0&0&1
}\right]
$$


```python
# 单位矩阵
np.identity(3)
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])

np.eye(3)
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
```

矩阵 A 的逆 (Inversion) 记作 A<sup>-1</sup>，定义为一个矩阵使得
$$
A^{-1}A=I_n
$$
如果 A<sup>-1</sup>存在，线性方程组Ax=b的解为：
$$
A^{-1}Ax=I_nx=x=A^{-1}b
$$

```python
# 矩阵的逆
A = [[1.0,2.0],[3.0,4.0]]
A_inv = np.linalg.inv(A)
print('矩阵A的逆：', A_inv)

矩阵A的逆： [[-2.   1. ]
 [ 1.5 -0.5]]
```

### 2.4 线性相关和生成子空间

对于分析方程组的解，可以理解成，A的列向量看作从原点出发，指向不同的行走方向。这些列向量决定了有多少种方式可以到达b。同样，每个x表示每个方向要走多远。则x<sub>i</sub>表示在第i列上走多远：
$$
Ax=\sum_i{x_iA_{:,i}}
$$
这种操作叫线性组合（linear combination）。一组向量的线性组合是每个向量v<sup>(i)</sup>乘以扩张系数加起来的结果：
$$
\sum_i{c_iv^{(i)}}
$$
一组向量空间（span）是通过线性组合能到达的所有点的集合。

判断Ax=b有解，等同于检测b是否在A的列向量生成子空间（span）中。这个特殊的生成子空间成为A的列空间（column spcae）或者A的值域（range）。A的列空间是整个R<sup>m</sup>的要求，意味着A至少有m列，即n>=m。但这只是不要条件（necessary condition），不是充分条件（sufficenti condition）。因为有些列向量是多余的，有些列向量是线性相关的，不能涵盖真实的列向量数目，某些列向量可以消掉，作用是一样的。

这种冗余被称为线性相关（linear dependence），一组向量中，任何一个向量都不向量组的线性组合，称向量组线性无关（linear independent）。矩阵可逆要确保Ax=b最多有一个解，也就是特解。因此确保矩阵最多有m列。综上所述，矩阵必须是方阵，所有的列必须是线性无关的。带有线性相关列向量的方阵成为奇异矩阵（singular）。如果矩阵 A 不是一个方阵或者是一个奇异的方阵，该方程仍然可能有解。但是我们不能使用矩阵逆去求解。



